/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "@azure/ms-rest-js";
import * as Models from "./models";
import * as Mappers from "./models/mappers";
import * as Parameters from "./models/parameters";
import { BatchTextTranslationAPIContext } from "./batchTextTranslationAPIContext";

class BatchTextTranslationAPI extends BatchTextTranslationAPIContext {
  /**
   * Initializes a new instance of the BatchTextTranslationAPI class.
   * @param credentials Subscription credentials which uniquely identify client subscription.
   * @param [options] The parameter options
   */
  constructor(credentials: msRest.ServiceClientCredentials, options?: Models.BatchTextTranslationAPIOptions) {
    super(credentials, options);
  }

  /**
   * Submit a batch request to the document translation service.
   *
   * Each request can consists of multiple inputs.
   * Each input will contains both a source and destination container for source and target language
   * pair.
   *
   * The prefix and suffix filter (if supplied) will be used to filter the folders.
   * The prefix will be applied to the subpath after the container name
   *
   * Glossaries / Translation memory can be supplied and will be applied when the document is being
   * translated.
   * If the glossary is invalid or unreachable during translation time.  An error will be indicated
   * in the document status.
   *
   * If the file with the same name already exists in the destination, it will be overwritten.
   * TargetUrl for each target language needs to be unique.
   * @summary Submit a batch document translation request to the translation service
   * @param [options] The optional parameters
   * @returns Promise<Models.BatchDocumentsSubmitResponse>
   */
  batchDocumentsSubmit(options?: Models.BatchTextTranslationAPIBatchDocumentsSubmitOptionalParams): Promise<Models.BatchDocumentsSubmitResponse>;
  /**
   * @param callback The callback
   */
  batchDocumentsSubmit(callback: msRest.ServiceCallback<Models.ErrorResponseV2>): void;
  /**
   * @param options The optional parameters
   * @param callback The callback
   */
  batchDocumentsSubmit(options: Models.BatchTextTranslationAPIBatchDocumentsSubmitOptionalParams, callback: msRest.ServiceCallback<Models.ErrorResponseV2>): void;
  batchDocumentsSubmit(options?: Models.BatchTextTranslationAPIBatchDocumentsSubmitOptionalParams | msRest.ServiceCallback<Models.ErrorResponseV2>, callback?: msRest.ServiceCallback<Models.ErrorResponseV2>): Promise<Models.BatchDocumentsSubmitResponse> {
    return this.sendOperationRequest(
      {
        options
      },
      batchDocumentsSubmitOperationSpec,
      callback) as Promise<Models.BatchDocumentsSubmitResponse>;
  }

  /**
   * Returns the status of the list of documents translation operation status in the subscription
   *
   * The documents are sorted by the document Id
   *
   * If the number of documents exceed our paging limit, server side paging will be used.
   * Paginated responses will indicate a partial result by including a continuation token in the
   * response. The absence of a continuation token means that no additional pages are available.
   *
   * Clients MAY use $top and $skip query parameters to specify a number of results to return and an
   * offset into the collection.
   * The server will honor the values specified by the client; however, clients MUST be prepared to
   * handle responses that contain a different page size or contain a continuation token.
   * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then
   * $top on the collection.
   * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client
   * informing about it instead of just ignoring the query options. This will avoid the risk of the
   * client making assumptions about the data returned.
   * @summary Returns the status of the documents of a translation batch operation
   * @param [options] The optional parameters
   * @returns Promise<Models.GetDetailedDocumentStatusResponse>
   */
  getDetailedDocumentStatus(options?: Models.BatchTextTranslationAPIGetDetailedDocumentStatusOptionalParams): Promise<Models.GetDetailedDocumentStatusResponse>;
  /**
   * @param callback The callback
   */
  getDetailedDocumentStatus(callback: msRest.ServiceCallback<any>): void;
  /**
   * @param options The optional parameters
   * @param callback The callback
   */
  getDetailedDocumentStatus(options: Models.BatchTextTranslationAPIGetDetailedDocumentStatusOptionalParams, callback: msRest.ServiceCallback<any>): void;
  getDetailedDocumentStatus(options?: Models.BatchTextTranslationAPIGetDetailedDocumentStatusOptionalParams | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetDetailedDocumentStatusResponse> {
    return this.sendOperationRequest(
      {
        options
      },
      getDetailedDocumentStatusOperationSpec,
      callback) as Promise<Models.GetDetailedDocumentStatusResponse>;
  }

  /**
   * Use content-type header to denote the file format type
   *
   * Example:
   * text/plain for .txt files
   * application/vnd.openxmlformats-officedocument.wordprocessingml.document for .docx files
   * application/pdf for .pdf files
   * @summary Submit a binary document in the POST body to the translation service.
   * @param targetLanguage The language code for the documents to translate to
   * @param [options] The optional parameters
   * @returns Promise<Models.SingleDocumentUploadResponse>
   */
  singleDocumentUpload(targetLanguage: string, options?: Models.BatchTextTranslationAPISingleDocumentUploadOptionalParams): Promise<Models.SingleDocumentUploadResponse>;
  /**
   * @param targetLanguage The language code for the documents to translate to
   * @param callback The callback
   */
  singleDocumentUpload(targetLanguage: string, callback: msRest.ServiceCallback<any>): void;
  /**
   * @param targetLanguage The language code for the documents to translate to
   * @param options The optional parameters
   * @param callback The callback
   */
  singleDocumentUpload(targetLanguage: string, options: Models.BatchTextTranslationAPISingleDocumentUploadOptionalParams, callback: msRest.ServiceCallback<any>): void;
  singleDocumentUpload(targetLanguage: string, options?: Models.BatchTextTranslationAPISingleDocumentUploadOptionalParams | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.SingleDocumentUploadResponse> {
    return this.sendOperationRequest(
      {
        targetLanguage,
        options
      },
      singleDocumentUploadOperationSpec,
      callback) as Promise<Models.SingleDocumentUploadResponse>;
  }

  /**
   * Returns the status of the translation of the document.
   * @summary Returns the status of the specific document
   * @param documentId Format - int64.  The document id
   * @param [options] The optional parameters
   * @returns Promise<Models.GetDocumentStatusResponse>
   */
  getDocumentStatus(documentId: number, options?: msRest.RequestOptionsBase): Promise<Models.GetDocumentStatusResponse>;
  /**
   * @param documentId Format - int64.  The document id
   * @param callback The callback
   */
  getDocumentStatus(documentId: number, callback: msRest.ServiceCallback<any>): void;
  /**
   * @param documentId Format - int64.  The document id
   * @param options The optional parameters
   * @param callback The callback
   */
  getDocumentStatus(documentId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  getDocumentStatus(documentId: number, options?: msRest.RequestOptionsBase | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetDocumentStatusResponse> {
    return this.sendOperationRequest(
      {
        documentId,
        options
      },
      getDocumentStatusOperationSpec,
      callback) as Promise<Models.GetDocumentStatusResponse>;
  }

  /**
   * Returns the status of the translation batch operation.
   * The status will include the overall job status as well as a summary of the current progress of
   * all the documents being translated.
   * @summary Returns the status of the batch translation operation
   * @param id Format - uuid.  The operation id
   * @param [options] The optional parameters
   * @returns Promise<Models.GetOperationStatusResponse>
   */
  getOperationStatus(id: string, options?: msRest.RequestOptionsBase): Promise<Models.GetOperationStatusResponse>;
  /**
   * @param id Format - uuid.  The operation id
   * @param callback The callback
   */
  getOperationStatus(id: string, callback: msRest.ServiceCallback<any>): void;
  /**
   * @param id Format - uuid.  The operation id
   * @param options The optional parameters
   * @param callback The callback
   */
  getOperationStatus(id: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  getOperationStatus(id: string, options?: msRest.RequestOptionsBase | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetOperationStatusResponse> {
    return this.sendOperationRequest(
      {
        id,
        options
      },
      getOperationStatusOperationSpec,
      callback) as Promise<Models.GetOperationStatusResponse>;
  }

  /**
   * Cancel a currently processing or queued operation.
   * An operation will not be cancelled if it is already completed or failed or cancelling.  A bad
   * request will be returned.
   * All documents that have completed translation will not be cancelled and will be charged.
   * All pending documents will be cancelled if possible.
   * @summary Cancel a currently processing or queued operation.
   * @param id Format - uuid.  The operation-id
   * @param [options] The optional parameters
   * @returns Promise<Models.CancelOperationResponse>
   */
  cancelOperation(id: string, options?: msRest.RequestOptionsBase): Promise<Models.CancelOperationResponse>;
  /**
   * @param id Format - uuid.  The operation-id
   * @param callback The callback
   */
  cancelOperation(id: string, callback: msRest.ServiceCallback<any>): void;
  /**
   * @param id Format - uuid.  The operation-id
   * @param options The optional parameters
   * @param callback The callback
   */
  cancelOperation(id: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  cancelOperation(id: string, options?: msRest.RequestOptionsBase | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.CancelOperationResponse> {
    return this.sendOperationRequest(
      {
        id,
        options
      },
      cancelOperationOperationSpec,
      callback) as Promise<Models.CancelOperationResponse>;
  }

  /**
   * Returns the status of the list of documents translation operation by a given operation id.
   *
   * The documents are sorted by the document Id
   *
   * If the number of documents exceed our paging limit, server side paging will be used.
   * Paginated responses will indicate a partial result by including a continuation token in the
   * response. The absence of a continuation token means that no additional pages are available.
   *
   * Clients MAY use $top and $skip query parameters to specify a number of results to return and an
   * offset into the collection.
   * The server will honor the values specified by the client; however, clients MUST be prepared to
   * handle responses that contain a different page size or contain a continuation token.
   * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then
   * $top on the collection.
   * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client
   * informing about it instead of just ignoring the query options. This will avoid the risk of the
   * client making assumptions about the data returned.
   * @summary Returns the status of the documents of a translation batch operation
   * @param id Format - uuid.  The operation id
   * @param [options] The optional parameters
   * @returns Promise<Models.GetDetailedDocumentStatusforagivenoperationidResponse>
   */
  getDetailedDocumentStatusForAGivenOperationId(id: string, options?: Models.BatchTextTranslationAPIGetDetailedDocumentStatusForAGivenOperationIdOptionalParams): Promise<Models.GetDetailedDocumentStatusforagivenoperationidResponse>;
  /**
   * @param id Format - uuid.  The operation id
   * @param callback The callback
   */
  getDetailedDocumentStatusForAGivenOperationId(id: string, callback: msRest.ServiceCallback<any>): void;
  /**
   * @param id Format - uuid.  The operation id
   * @param options The optional parameters
   * @param callback The callback
   */
  getDetailedDocumentStatusForAGivenOperationId(id: string, options: Models.BatchTextTranslationAPIGetDetailedDocumentStatusForAGivenOperationIdOptionalParams, callback: msRest.ServiceCallback<any>): void;
  getDetailedDocumentStatusForAGivenOperationId(id: string, options?: Models.BatchTextTranslationAPIGetDetailedDocumentStatusForAGivenOperationIdOptionalParams | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetDetailedDocumentStatusforagivenoperationidResponse> {
    return this.sendOperationRequest(
      {
        id,
        options
      },
      getDetailedDocumentStatusForAGivenOperationIdOperationSpec,
      callback) as Promise<Models.GetDetailedDocumentStatusforagivenoperationidResponse>;
  }

  /**
   * Returns the list of status of the translation batch operation.
   * The list will consist only of the batch request submitted by the user (based on their
   * subscription)
   *
   * The operation status are sorted by the operation Id
   *
   * If the number of operations exceed our paging limit, server side paging will be used.
   * Paginated responses will indicate a partial result by including a continuation token in the
   * response. The absence of a continuation token means that no additional pages are available.
   *
   * Clients MAY use $top and $skip query parameters to specify a number of results to return and an
   * offset into the collection.
   * The server will honor the values specified by the client; however, clients MUST be prepared to
   * handle responses that contain a different page size or contain a continuation token.
   * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then
   * $top on the collection.
   * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client
   * informing about it instead of just ignoring the query options. This will avoid the risk of the
   * client making assumptions about the data returned.
   * @summary Returns the list of operations submitted and their summary status
   * @param [options] The optional parameters
   * @returns Promise<Models.GetstatusofoperationlistResponse>
   */
  getStatusOfOperationList(options?: Models.BatchTextTranslationAPIGetStatusOfOperationListOptionalParams): Promise<Models.GetstatusofoperationlistResponse>;
  /**
   * @param callback The callback
   */
  getStatusOfOperationList(callback: msRest.ServiceCallback<any>): void;
  /**
   * @param options The optional parameters
   * @param callback The callback
   */
  getStatusOfOperationList(options: Models.BatchTextTranslationAPIGetStatusOfOperationListOptionalParams, callback: msRest.ServiceCallback<any>): void;
  getStatusOfOperationList(options?: Models.BatchTextTranslationAPIGetStatusOfOperationListOptionalParams | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetstatusofoperationlistResponse> {
    return this.sendOperationRequest(
      {
        options
      },
      getStatusOfOperationListOperationSpec,
      callback) as Promise<Models.GetstatusofoperationlistResponse>;
  }

  /**
   * The list of supported document formats supported by our service.
   * The list will include the common file extension used and supported as well as the content-type
   * if using the upload API.
   * @summary Returns the list of supported document formats
   * @param [options] The optional parameters
   * @returns Promise<Models.GetDocumentFormatsResponse>
   */
  getDocumentFormats(options?: msRest.RequestOptionsBase): Promise<Models.GetDocumentFormatsResponse>;
  /**
   * @param callback The callback
   */
  getDocumentFormats(callback: msRest.ServiceCallback<any>): void;
  /**
   * @param options The optional parameters
   * @param callback The callback
   */
  getDocumentFormats(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  getDocumentFormats(options?: msRest.RequestOptionsBase | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetDocumentFormatsResponse> {
    return this.sendOperationRequest(
      {
        options
      },
      getDocumentFormatsOperationSpec,
      callback) as Promise<Models.GetDocumentFormatsResponse>;
  }

  /**
   * The list of supported glossary formats supported by our service.
   * The list will include the common file extension used.
   * @summary Returns the list of supported document formats
   * @param [options] The optional parameters
   * @returns Promise<Models.GetGlossaryFormatsResponse>
   */
  getGlossaryFormats(options?: msRest.RequestOptionsBase): Promise<Models.GetGlossaryFormatsResponse>;
  /**
   * @param callback The callback
   */
  getGlossaryFormats(callback: msRest.ServiceCallback<any>): void;
  /**
   * @param options The optional parameters
   * @param callback The callback
   */
  getGlossaryFormats(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  getGlossaryFormats(options?: msRest.RequestOptionsBase | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetGlossaryFormatsResponse> {
    return this.sendOperationRequest(
      {
        options
      },
      getGlossaryFormatsOperationSpec,
      callback) as Promise<Models.GetGlossaryFormatsResponse>;
  }

  /**
   * The list of storage sources supported by our service.
   * @summary Returns the list of supported storage sources
   * @param [options] The optional parameters
   * @returns Promise<Models.GetStorageSourcesThatWeCurrentlySupportResponse>
   */
  getStorageSourcesThatWeCurrentlySupport(options?: msRest.RequestOptionsBase): Promise<Models.GetStorageSourcesThatWeCurrentlySupportResponse>;
  /**
   * @param callback The callback
   */
  getStorageSourcesThatWeCurrentlySupport(callback: msRest.ServiceCallback<any>): void;
  /**
   * @param options The optional parameters
   * @param callback The callback
   */
  getStorageSourcesThatWeCurrentlySupport(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<any>): void;
  getStorageSourcesThatWeCurrentlySupport(options?: msRest.RequestOptionsBase | msRest.ServiceCallback<any>, callback?: msRest.ServiceCallback<any>): Promise<Models.GetStorageSourcesThatWeCurrentlySupportResponse> {
    return this.sendOperationRequest(
      {
        options
      },
      getStorageSourcesThatWeCurrentlySupportOperationSpec,
      callback) as Promise<Models.GetStorageSourcesThatWeCurrentlySupportResponse>;
  }
}

// Operation Specifications
const serializer = new msRest.Serializer(Mappers);
const batchDocumentsSubmitOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "translator/text/batch/v1.0-preview.1/documents",
  requestBody: {
    parameterPath: [
      "options",
      "body"
    ],
    mapper: Mappers.JobSubmissionBatchRequest
  },
  responses: {
    202: {
      headersMapper: Mappers.BatchDocumentsSubmitHeaders
    },
    400: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.BatchDocumentsSubmitHeaders
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.BatchDocumentsSubmitHeaders
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.BatchDocumentsSubmitHeaders
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.BatchDocumentsSubmitHeaders
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.BatchDocumentsSubmitHeaders
    },
    default: {}
  },
  serializer
};

const getDetailedDocumentStatusOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/documents",
  queryParameters: [
    Parameters.top,
    Parameters.skip
  ],
  responses: {
    200: {
      bodyMapper: Mappers.DocumentStatusResponse,
      headersMapper: Mappers.GetDetailedDocumentStatusHeaders
    },
    400: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusHeaders
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusHeaders
    },
    404: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusHeaders
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusHeaders
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusHeaders
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusHeaders
    },
    default: {}
  },
  serializer
};

const singleDocumentUploadOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "translator/text/batch/v1.0-preview.1/documents/upload",
  queryParameters: [
    Parameters.sourceLanguage,
    Parameters.category,
    Parameters.targetLanguage
  ],
  responses: {
    201: {
      bodyMapper: Mappers.DocumentSubmissionResponse,
      headersMapper: Mappers.SingleDocumentUploadHeaders
    },
    400: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.SingleDocumentUploadHeaders
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.SingleDocumentUploadHeaders
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.SingleDocumentUploadHeaders
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.SingleDocumentUploadHeaders
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.SingleDocumentUploadHeaders
    },
    default: {}
  },
  serializer
};

const getDocumentStatusOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/documents/{documentId}",
  urlParameters: [
    Parameters.documentId
  ],
  responses: {
    200: {
      bodyMapper: Mappers.DocumentStatusDetail,
      headersMapper: Mappers.GetDocumentStatusHeaders
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDocumentStatusHeaders
    },
    404: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDocumentStatusHeaders
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDocumentStatusHeaders
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDocumentStatusHeaders
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDocumentStatusHeaders
    },
    default: {}
  },
  serializer
};

const getOperationStatusOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/operations/{id}",
  urlParameters: [
    Parameters.id
  ],
  responses: {
    200: {
      bodyMapper: Mappers.OperationStatusSummary,
      headersMapper: Mappers.GetOperationStatusHeaders
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetOperationStatusHeaders
    },
    404: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetOperationStatusHeaders
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetOperationStatusHeaders
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetOperationStatusHeaders
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetOperationStatusHeaders
    },
    default: {}
  },
  serializer
};

const cancelOperationOperationSpec: msRest.OperationSpec = {
  httpMethod: "DELETE",
  path: "translator/text/batch/v1.0-preview.1/operations/{id}",
  urlParameters: [
    Parameters.id
  ],
  responses: {
    200: {
      bodyMapper: Mappers.OperationStatusSummary
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    404: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    default: {}
  },
  serializer
};

const getDetailedDocumentStatusForAGivenOperationIdOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/operations/{id}/documents",
  urlParameters: [
    Parameters.id
  ],
  queryParameters: [
    Parameters.top,
    Parameters.skip
  ],
  responses: {
    200: {
      bodyMapper: Mappers.DocumentStatusResponse,
      headersMapper: Mappers.GetDetailedDocumentStatusforagivenoperationidHeaders
    },
    400: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusforagivenoperationidHeaders
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusforagivenoperationidHeaders
    },
    404: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusforagivenoperationidHeaders
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusforagivenoperationidHeaders
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusforagivenoperationidHeaders
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetDetailedDocumentStatusforagivenoperationidHeaders
    },
    default: {}
  },
  serializer
};

const getStatusOfOperationListOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/operations",
  queryParameters: [
    Parameters.top,
    Parameters.skip
  ],
  responses: {
    200: {
      bodyMapper: Mappers.OperationStatusResponse,
      headersMapper: Mappers.GetstatusofoperationlistHeaders
    },
    400: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetstatusofoperationlistHeaders
    },
    401: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetstatusofoperationlistHeaders
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetstatusofoperationlistHeaders
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetstatusofoperationlistHeaders
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2,
      headersMapper: Mappers.GetstatusofoperationlistHeaders
    },
    default: {}
  },
  serializer
};

const getDocumentFormatsOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/documents/formats",
  responses: {
    200: {
      bodyMapper: Mappers.FileFormatListResult
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    default: {}
  },
  serializer
};

const getGlossaryFormatsOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/glossaries/formats",
  responses: {
    200: {
      bodyMapper: Mappers.FileFormatListResult
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    default: {}
  },
  serializer
};

const getStorageSourcesThatWeCurrentlySupportOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "translator/text/batch/v1.0-preview.1/storagesources",
  responses: {
    200: {
      bodyMapper: Mappers.StorageSourceListResult
    },
    429: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    500: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    503: {
      bodyMapper: Mappers.ErrorResponseV2
    },
    default: {}
  },
  serializer
};

export {
  BatchTextTranslationAPI,
  BatchTextTranslationAPIContext,
  Models as BatchTextTranslationAPIModels,
  Mappers as BatchTextTranslationAPIMappers
};
